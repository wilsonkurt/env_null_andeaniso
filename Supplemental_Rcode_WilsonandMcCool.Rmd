---
title: "Supplemental R Code for Wilson and McCool"
author: "Kurt Wilson"
date: "3/25/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("C:/Users/Kurt/Box Sync/Env_Null_AmerInd")
```

This supplemental material is from The Environmental Null: Documenting the Changing Influence of Physical and Social Environments on Prehistoric Andean Diets. The corresponding author, Kurt M. Wilson, may be contacted at [kurt.wilson@utah.edu](mailto:kurt.wilson@utah.edu). The code below is the complete code to rerun the analyses performed in the manuscript. 

#Load packages used in this data creation and analysis
```{r load packages, message=FALSE, warning=FALSE}
#autocorrelation and collinearity
  library(ape)
  library(corrplot)

#gam
  library(mgcv)

#load color libraries
  library(viridis)
  library(scales)

#boot to calculate inverse of logit
  library(boot)

#weighted row mean and sd
  library(matrixStats)

#for mapping
library(maps)       # Provides functions that let us plot the maps
library(mapdata)    # Contains the hi-resolution points that mark out the countries. 
library(raster)#mapping and working with spatial data
library(rgdal)#mapping and shapefile reading
library(ncdf4)#working with netcdf files
library(maptools)#mapping
library(sf)#shapefile reading and analysis
library(sp)#shapefile reading and analysis
library(rgeos)
library(spatstat) #enables creating owin object required for the stkde function in rcarbon
library(GISTools)


```

1 Importing the data
All of the data for this analysis is available in the supplemental data file for Wilson et al. in prep. The data may be downloaded as a csv. Once the csv file is downloaded, proceed with the code below.

Read in the csv supplemenatl data file. This file has the data required for this analysis and some extra individuals we need to drop out. 
```{r dat new}
dat <- read.csv("Supplemental_Data.csv")

#Subset the data to keep only the individuals from our periods of interest
dat <- dat[which(dat$Phase == "Early Intermediate Period" | dat$Phase == "Middle Horizon" | dat$Phase == "Late Intermediate Period" | dat$Phase == "Late Horizon"),]

```

If you are only interested in the analysis portion, please skip down to 5. The next sets of code would allow you to recreate the paleoclimate data.

2 Recreating the climatic variable data

2.1 To recreate the climate data will require the use of the PaleoView Paleoclimate Reconstruction (Fordham et al 2017). The PaleoView tool relies on climate data from the Trace-21ka climatic reconstruction. To download PaleoView follow the github website link below. Within PaleoView, generate data files from the Map Grid as netcdf files. For this work, we generated netcdf files for annual mean temperature, annual mean precipitation, precipitation seasonality, and temperature seasonality from 11,000 to 140 ybp with interval steps of 20 years (meaning a data point every 20 years) with an interval size of 30 years (meaning the data point is averaged with a +- 30 around the specified year) [see PaleoView ? help buttons for more details]. Values are not relative to any point in time but estimated values applying model bias correction. For more information, follow links below.


Climate data from Simulation of the Transient Climate of the Last 21,000 Years (TraCE-21ka) obtained via Paleoview
  - https://github.com/GlobalEcologyLab/PaleoView/ 
  - Values generated on map grid at annual intervals from 11,000 to 140 yBP with interval steps of 20 years and interval sizes of 30 years
  - Values are estimated actual values
  - https://onlinelibrary.wiley.com/doi/epdf/10.1111/ecog.03031 (website for paleoview journal article)

Also, see: 
  - https://www.earthsystemgrid.org/dataset/ucar.cgd.ccsm3.trace.html
  - http://www.cesm.ucar.edu/working_groups/Paleo/documentation/sims-projects/trace-21ka/
  - http://www.cgd.ucar.edu/ccr/TraCE/

Vignettes for working with netcdf files: 
  - https://www.r-bloggers.com/a-netcdf-4-in-r-cheatsheet/
  - http://geog.uoregon.edu/bartlein/courses/geog490/week04-netCDF.html
  - https://cran.r-project.org/web/packages/futureheatwaves/vignettes/starting_from_netcdf.html


2.2 Load the PaleoView climatic data:

```{r read data, warning=FALSE}

#Netcdf files generated by PaleoView will be named as "Mean_Temperature_Annual_11000BP-140BP_step20_size30.nc". The file name is the name to use as varname when reading in a netcdf file as a raster brick (as below). Note that here the netcdf file bricks have a slightly different name (Mean_Temperature_Annual.nc) as I renamed them prior to use.

r_brick <- brick("Mean_Temperature_Annual.nc", varname="Mean_Temperature_Annual_11000BP-140BP_step20_size30") #read and create raster brick of mean temp from the netcdf file

r_brick_precip <- brick("Mean_Precipitation_Annual.nc", varname = "Mean_Precipitation_Annual_11000BP-140BP_step20_size30")#read and create raster brick of mean precip from the netcdf file

r_brick_tsea <- brick("Temperature_Seasonality_Annual.nc", varname = "Temperature_Seasonality_Annual_11000BP-140BP_step20_size30")#read and create raster brick of temp seasonality

r_brick_psea <- brick("Precipitation_Seasonality_Annual.nc", varname = "Precipitation_Seasonality_Annual_11000BP-140BP_step20_size30")
```

2.3 Plot an example to check how the data looks

First, pull in some additional shapefiles for mapping the coastlines and the political boundaries. Shapefiles for the coast are from the NOAA Global Self-consistent, Hierarchical, High-resolution Geography Database (GSHHG) accessed at http://www.soest.hawaii.edu/pwessel/gshhg/ or https://www.ngdc.noaa.gov/mgg/shorelines/data/gshhg/latest/. Files for the political boundaries are from the CIA World Data Bank II accessed at http://www.soest.hawaii.edu/pwessel/gshhg/ or https://www.evl.uic.edu/pape/data/WDB/.

```{r}
coasts <- st_read("GSHHS_h_L1.shp")#World Vector Shorelines (WVS) coastal file.
WDBII <- st_read("WDBII_border_h_l1.shp")#Political boundaries.  #st_read function from sf package

#Now crop the coasts and political boundary files so they are not so large.
y <- extent(-85,-25,-25,5)#xmin, xmax, ymin, ymax 
crop.coast <- st_crop(coasts, y)
crop.wdbii <- st_crop(WDBII, y)

```
Now plot mean temperature and precipitation at 11,000 ybp.
```{r}
#This will plot the variation in mean annual temperature and precipitation at 11000 ybp.

par(oma=c(3,4,1,3))
par(mfrow=c(1,2), pty="s")
par(mar=c(1.5,1.5,0.5,1.5))
plot(r_brick, y="X.11000", col=gray.colors(30, start = 0), ylim=c(-25,0), xlim=c(-85,-65), zlim = c(7,25), main = "") #plot global values at 11000 BP
plot(crop.coast$geometry, add = T, lwd = 1.5)#plot the coastlines
plot(crop.wdbii$geometry, add = T, lwd = 1.5)#plot political boundaries from the CIA databasewith(plot.sites, points(Latitude~Longitude, pch=22, bg="white"))
mtext(expression(paste("Mean Temperature ",degree,"C")), side = 1, line = -1, at = -77.5, las = 1)
mtext("Latitude", side = 2, line = 3, at = -4.5, adj = 2)
mtext(expression(paste(degree,"C")), side = 4, line = 1, at = -3.5, las = 1)

plot(r_brick_precip, y="X.11000", col=rev(gray.colors(30, start = 0)), ylim=c(-25,0), xlim=c(-85,-65), zlim = c(0, 7), main = "", yaxt = "n") #plot global values at 11000 BP
plot(crop.coast$geometry, add = T, lwd = 1.5)#plot the coastlines
plot(crop.wdbii$geometry, add = T, lwd = 1.5)#plot political boundaries from the CIA databasewith(plot.sites, points(Latitude~Longitude, pch=22, bg="white"))
mtext("Mean Precip (mm/day)", side = 1, line = -1, at = -77.5, las = 1)
mtext("Longitude", side = 1, line = 3, at = -90.5, las = 1)
mtext("mm/day", side = 4, line = 0.9, at = -3.5, las = 1)
```



3 Extracting climate data for each individual based on their location and date range.

3.1 First, write function to extract time series for each point, then summarize climate value (temperature and precip means and standard deviations) for estimated years:

```{r function to extract data for each site and time}

result<-data.frame() #create a blank data frame to hold result

#####Function for Mean Temp#####

ClimTExt<-function(x, result){                                #write a function to extract time series, then caculate summary for subset time period
vals <- raster::extract(r_brick, matrix(c(x$Longitude, x$Latitude), ncol = 2)) # long and lat in cols 4 and 3 respectively.

tdat<-data.frame("year"=rev(seq(from=140, to=11000, by=20)), #index the time series by year
           "temp"=t(vals)[,1]                                #transpose the result as a column
           )

rownames(tdat) <- c() #drop row names
    
result<-
 mean(                                                     #calcualte mean (note: can change this to any other function, like SD as needed)
  subset(                                                  #subset data
    tdat, year>=x$End.BP & year<=x$Start.BP, select=temp   #from younger date to older date (start is older in this db)
    )$temp                                                 #return temp
 )
}

dat<-dat #assign the points to "dat"

Ind_Temp<-by(dat, INDICES=1:nrow(dat), FUN=ClimTExt, simplify = TRUE) #apply the function to each row using "by"

dat_export<-
  data.frame( #create a new data frame of the results
  dat,      #the original data frame
  "Temp_Mean"=matrix(Ind_Temp) #summarize the results as a matrix bound to dat
)

dat <- cbind(dat, dat_export$Temp_Mean)#add the newly acquired mean temp data to the db

#####Function for Mean Precip#####

ClimPExt<-function(x, result){                                #write a function to extract time series, then caculate summary for subset time period
vals <- raster::extract(r_brick_precip, matrix(c(x$Longitude, x$Latitude), ncol = 2)) # long and lat in cols 4 and 3 respectively

tdat<-data.frame("year"=rev(seq(from=140, to=11000, by=20)), #index the time series by year
           "precip"=t(vals)[,1]                                #transpose the result as a column
           )

rownames(tdat) <- c() #drop row names
    
result<-
 mean(                                                     #calcualte mean (note: can change this to any other function, like SD as needed)
  subset(                                                  #subset data
    tdat, year>=x$End.BP & year<=x$Start.BP, select=precip   #from younger date to older date (start is older in this db)
    )$precip                                                 #return temp
 )
}


Ind_Precip<-by(dat, INDICES=1:nrow(dat), FUN=ClimPExt, simplify = TRUE) #apply the function to each row using "by"

dat_export<-
  data.frame( #create a new data frame of the results
  dat_export,      #the original data frame
  "Precip_Mean"=matrix(Ind_Precip) #summarize the results as a matrix bound to dat
)
dat <- cbind(dat, dat_export$Precip_Mean)

#####Function for Mean Temp Seasonality#####
ClimTExt<-function(x, result){                                #write a function to extract time series, then caculate summary for subset time period
vals <- raster::extract(r_brick_tsea, matrix(c(x$Longitude, x$Latitude), ncol = 2)) # long and lat in cols 4 and 3 respectively

tdat<-data.frame("year"=rev(seq(from=140, to=11000, by=20)), #index the time series by year
           "temp_sea"=t(vals)[,1]                                #transpose the result as a column
           )

rownames(tdat) <- c() #drop row names
    
result<-
 mean(                                                     #calcualte mean (note: can change this to any other function, like SD as needed)
  subset(                                                  #subset data
    tdat, year>=x$End.BP & year<=x$Start.BP, select=temp_sea   #from younger date to older date (start is older in this db)
    )$temp_sea                                                 #return temp
 )
}

dat<-dat #assign the points to "dat"

Sea_Temp<-by(dat, INDICES=1:nrow(dat), FUN=ClimTExt, simplify = TRUE) #apply the function to each row using "by"

dat_export<-
  data.frame( #create a new data frame of the results
  dat,      #the original data frame
  "Temp_Mean_Seasonality"=matrix(Sea_Temp) #summarize the results as a matrix bound to dat
)

dat <- cbind(dat, dat_export$Temp_Mean_Seasonality)

#####Function for Mean Precip Seasonality#####
ClimTExt<-function(x, result){                                #write a function to extract time series, then caculate summary for subset time period
vals <- raster::extract(r_brick_psea, matrix(c(x$Longitude, x$Latitude), ncol = 2)) # long and lat in cols 4 and 3 respectively

tdat<-data.frame("year"=rev(seq(from=140, to=11000, by=20)), #index the time series by year
           "precip_sea"=t(vals)[,1]                                #transpose the result as a column
           )

rownames(tdat) <- c() #drop row names
    
result<-
 mean(                                                     #calcualte mean (note: can change this to any other function, like SD as needed)
  subset(                                                  #subset data
    tdat, year>=x$End.BP & year<=x$Start.BP, select=precip_sea   #from younger date to older date (start is older in this db)
    )$precip_sea                                                 #return temp
 )
}

dat<-dat #assign the points to "dat"

Sea_Precip<-by(dat, INDICES=1:nrow(dat), FUN=ClimTExt, simplify = TRUE) #apply the function to each row using "by"

dat_export<-
  data.frame( #create a new data frame of the results
  dat,      #the original data frame
  "Precip_Mean_Seasonality"=matrix(Sea_Precip) #summarize the results as a matrix bound to dat
)

dat <- cbind(dat, dat_export$Precip_Mean_Seasonality)

#Rename the new columns - Check to be sure the column number is correct before renaming.
#colnames(isodat)[22] <- "Temp_Mean"#rename the distance to coast column as dist2coast
#colnames(isodat)[23] <- "Precip_Mean"#rename the distance to coast column as dist2coast
#colnames(isodat)[24] <- "Temp_Mean_Seasonality"#rename the distance to coast column as dist2coast
#colnames(isodat)[25] <- "Precip_Mean_Seasonality"#rename the distance to coast column as dist2coast



```

4 Extracting Elevation and Distance to Coast

4.1 To construct the DEM, download  tile tif files from the USGS EarthExplore (https://earthexplorer.usgs.gov/). They may then be read into R and converted into a geotiff file. Note - over 700 individual tif files were downloaded and compiled to create the DEM used for extracting site elevations. The tif bounding box is -82.00042, -64.99958, -25.00042, 1.000417  (xmin, xmax, ymin, ymax).

```{r map dat}

#The function below will read in and stitch together all of the individual tif files to make one raster object.

#fn <- list.files(path = "C:/Users/Kurt/Box Sync/Peru Isotope Database/DEM/Individual_Tifs",
 #                pattern = "tif",
  #               full.names = TRUE)#obtain a list of all of the files (individual tifs) in the folder and place them in a single vector

#dem <- lapply(fn, raster::raster)#apply the raster function from the raster package to every file in the fn vector (every individual tif)

#dem <- do.call(what = raster::merge, 
    #           args = dem)#using the merge function in the raster package merge all of the individual tifs together to get one geo.tif that has all of the data

#writeRaster(dem, "Peru_NorthChile_dem.tif", "GTiff")#write a new geotiff file that is the composite of all the individuals

dem <- raster("Peru_NorthChile_dem.tif")#read the new geotiff file in
```

4.2 Calculate elevation for each site 
```{r elev}

table(is.na(dat$Latitude))#Check to see if any sites are missing Lat/Long data. None are
#dat <- dat[!is.na(dat$Longitude),]#select out cases without gps data if any are missing

points <- matrix(c(dat$Longitude, dat$Latitude), ncol = 2)#make a matrix of points
elevation <- raster::extract(dem, points, method = "simple", buffer = NULL, df = FALSE)#use the extract function to obtain the elevation - meters above sea level - for each site
#Macchu Picchu fails to get elevations, even with buffers. Elevation for the site was taken from published literature.

dat <- cbind(dat, elevation)#add the elevations to the isotope dataframe

```

4.3 Calculate the distance to the coast for each individual

```{r st dist}
crop_ext <- extent(dem)#extract the DEM extents to crop the coast shapefile to the DEM extents
coasts_crop <- st_crop(coasts, crop_ext)#crop the coast shapefile to the DEM extents
#st_write(coasts2_crop, 'cropped_coast.shp')#write the cropped shapefile so it may be read in and used in the future without relying on the world file
coasts_crop_line <- st_cast(coasts_crop, "LINESTRING")#convert from polygon to linestring because otherwise R calculates distance from points to a space within the polygon (inherently 0).
isodat_sf <- st_as_sf(dat, coords = c("Longitude", "Latitude"), crs = 4326)#convert the dat dataframe to a simple feature collection (sfc)
#plot(coasts_crop_line$geometry[[1]])#tried the plot to make sure it worked
dist2coast_m <- st_distance(coasts_crop_line, isodat_sf)#compute euclidean distance (m) between the lines in the linestring coasts2_crop_line file and the site points as a spatial file
dist2coast_df <- as.data.frame(dist2coast_m)#Produce a dataframe with the output of the distance calculations. We only care about the 1st distance calculation for each site (beacuse this is the distance to the bounding line). The other 245 calculations are to islands and other anomolies, not the direct coastline. 
dist2coast <- dist2coast_df[1,]#select only the distance to the first object (the coastline)
dist2coast <- t(dist2coast)#transpose so that there is 1 column with the distance and a row for each individual
dat <- cbind(dat, dist2coast)#add the distance to coast measure to the dataframe as a new column

#Edit the column name - Be sure to check that you are renaming the correct column
#colnames(dat)[21] <- "dist2coast"#rename the distance to coast column as dist2coast

```


4.4 Write everything to a final csv
```{r}

#write.csv(dat,"Supplemental_Data.csv", quote = TRUE)

```

4.5 Make Figure 3. Plot examples from the data for the study area: 

```{r plot data peru}

dat.plot <- dat[which((dat$Start.BP >= 1700 & dat$End.BP <=1700)),]#Grab individuals who have climate data from the year 1700 ybp included in their values
plot.sites <- dat.plot[ !duplicated(dat.plot$Site.ID),]#select one individual from each unique site. Use this for plotting.


#Plot temp and precip means at 1700 ybp (250 CE) and plot all sites which would include the 1700 ybp data in their average (n=27)

#png("temp_precip_map.png", width=8, height=8, units="in", res=300)
par(oma=c(3,4,1,3))
par(mfrow=c(1,2), pty="s")
par(mar=c(1.5,1.5,0.5,1.5))
#par(mgp=c(0,1,0))
plot(r_brick, y="X.1700", col=gray.colors(30, start = 0), ylim=c(-25,0), xlim=c(-85,-65), zlim = c(7,25), main = "") #plot global values at 11000 BP
plot(crop.coast$geometry, add = T, lwd = 1.5)#plot the coastlines
plot(crop.wdbii$geometry, add = T, lwd = 1.5)#plot political boundaries from the CIA databasewith(plot.sites, points(Latitude~Longitude, pch=22, bg="white"))
with(plot.sites, points(Latitude~Longitude, pch=22, bg="transparent"))
mtext("Mean Temp", side = 1, line = -1, at = -77.5, las = 1)
mtext("Latitude", side = 2, line = 3, at = -4.5, adj = 2)
mtext(expression(paste(degree,"C")), side = 4, line = 1, at = -3.5, las = 1)



plot(r_brick_precip, y="X.1700", col=rev(gray.colors(30, start = 0)), ylim=c(-25,0), xlim=c(-85,-65), zlim = c(0, 7), main = "", yaxt = "n") #plot global values at 11000 BP
plot(crop.coast$geometry, add = T, lwd = 1.5)#plot the coastlines
plot(crop.wdbii$geometry, add = T, lwd = 1.5)#plot political boundaries from the CIA databasewith(plot.sites, points(Latitude~Longitude, pch=22, bg="white"))
with(plot.sites, points(Latitude~Longitude, pch=22, bg="transparent"))
mtext("Mean Precip", side = 1, line = -1, at = -77.5, las = 1)
mtext("Longitude", side = 1, line = 3, at = -90.5, las = 1)
mtext("cm", side = 4, line = 0.9, at = -3.5, las = 1)
#dev.off()

```

5 Analysis. Begin here if you wish to rerun the analysis but not regenerate all of the individual data points. Be sure you have read in the data and run the code in Section 1.1 to select only individuals from the EIP through LH.

5.1 Set up the individual dataframes
```{r dat}

#Make sure elevation is reading as a numeric variable
dat$elevation <- as.numeric(dat$elevation)

#Set site.id as a factor so it may be used as a random effect in the GAM analyses
dat$Site.ID <- as.factor(dat$Site.ID)

#Generate tables for each time period
dat.eip <- dat[which(dat$Phase == 'Early Intermediate Period'),]
dat.mh <- dat[which(dat$Phase == 'Middle Horizon'),]
dat.lip <- dat[which(dat$Phase == 'Late Intermediate Period'),]
dat.lh <- dat[which(dat$Phase == 'Late Horizon'),]

dat.all <- dat


```

5.2 Let's check if duration has an influence on the dependent variables (N & C)
```{r check duration}
#calculate the time window size for each individual
duration <- dat.all$Start.BP - dat.all$End.BP

#add this to our dat dataframe
dat.all <- cbind(dat.all, duration)

#subset the dataframe for nitrogen and carbon
dat.all.n <- dat.all[!is.na(dat.all$N.b.coll.),]
dat.all.c <- dat.all[!is.na(dat.all$C.b.coll.),]

#plot the relationship between time window size and nitrogen or carbon value
par(mfrow = c(1,2))
plot(dat.all.n$N.b.coll.~dat.all.n$duration, ylab = "Nitrogen per mil", xlab = "Length of Temporal Window (yrs)")

plot(dat.all.c$C.b.coll.~dat.all.c$duration, ylab = "Carbon per mil", xlab = "Length of Temporal Window (yrs)")
```
These plots show no signs of consistent patterning in length of time window and dietary isotope. Duration is not having an influence

5.3 Generate summary statistics

First, make subsets for each time period and isotope
```{r summary stats}

#Generate subsets of the data for individuals with C and individuals with N by each time period
LH_C <- subset(dat.lh, !is.na(dat.lh$C.b.coll.))#leave out individuals with NA for N bone coll
LH_N <- subset(dat.lh, !is.na(dat.lh$N.b.coll.))#leave out individuals with NA for N bone coll

LIP_C <- subset(dat.lip, !is.na(dat.lip$C.b.coll.))#leave out individuals with NA for N bone coll
LIP_N <- subset(dat.lip, !is.na(dat.lip$N.b.coll.))#leave out individuals with NA for N bone coll

MH_C <- subset(dat.mh, !is.na(dat.mh$C.b.coll.))#leave out individuals with NA for N bone coll
MH_N <- subset(dat.mh, !is.na(dat.mh$N.b.coll.))#leave out individuals with NA for N bone coll

EIP_C <- subset(dat.eip, !is.na(dat.eip$C.b.coll.))#leave out individuals with NA for N bone coll
EIP_N <- subset(dat.eip, !is.na(dat.eip$N.b.coll.))#leave out individuals with NA for N bone coll

```

Calculate mean, median, and standard deviation of Nitrogen and Carbon for the EIP
```{r}
median(EIP_N$N.b.coll.)
mean(EIP_N$N.b.coll.)
sd(EIP_N$N.b.coll.)
median(EIP_C$C.b.coll.)
mean(EIP_C$C.b.coll.)
sd(EIP_C$C.b.coll.)

#Calculate the number of sites for the EIP
sites.EIPN <- unique(EIP_N$Site.ID)
length(sites.EIPN)
sites.EIPC <- unique(EIP_C$Site.ID)
length(sites.EIPC)

```
Calculate mean, median, and standard deviation of Nitrogen and Carbon for the MH
```{r}
median(MH_N$N.b.coll.)
mean(MH_N$N.b.coll.)
sd(MH_N$N.b.coll.)
median(MH_C$C.b.coll.)
mean(MH_C$C.b.coll.)
sd(MH_C$C.b.coll.)

#Calculate the number of sites for the MH
sites.MHN <- unique(MH_N$Site.ID)
length(sites.MHN)
sites.MHC <- unique(MH_C$Site.ID)
length(sites.MHC)

```

Calculate mean, median, and standard deviation of Nitrogen and Carbon for the LIP
```{r}

median(LIP_N$N.b.coll.)
mean(LIP_N$N.b.coll.)
sd(LIP_N$N.b.coll.)
median(LIP_C$C.b.coll.)
mean(LIP_C$C.b.coll.)
sd(LIP_C$C.b.coll.)

#Calculate the number of sites for the LIP

sites.LIPN <- unique(LIP_N$Site.ID)
length(sites.LIPN)
sites.LIPC <- unique(LIP_C$Site.ID)
length(sites.LIPC)

```

Calculate mean, median, and standard deviation of Nitrogen and Carbon for the LH
```{r}

median(LH_N$N.b.coll.)
mean(LH_N$N.b.coll.)
sd(LH_N$N.b.coll.)
median(LH_C$C.b.coll.)
mean(LH_C$C.b.coll.)
sd(LH_C$C.b.coll.)

#Calculate the number of sites for the LH
sites.LHN <- unique(LH_N$Site.ID)
length(sites.LHN)
sites.LHC <- unique(LH_C$Site.ID)
length(sites.LHC)

```

Calculate mean, median, and standard deviation of Nitrogen and Carbon for all individuals
```{r}
median(dat.all.n$N.b.coll.)
mean(dat.all.n$N.b.coll.)
sd(dat.all.n$N.b.coll.)
median(dat.all.c$C.b.coll.)
mean(dat.all.c$C.b.coll.)
sd(dat.all.c$C.b.coll.)

#Calculate the number of sites
sites.allN <- unique(dat.all.n$Site.ID)
length(sites.allN)
sites.allC <- unique(dat.all.c$Site.ID)
length(sites.allC)

```


5.4 Plot histograms of individuals by elevation for each time period to look at range of variation

```{r}

par(pty = "s", mfrow = c(2,2))
hist(EIP_N$elevation, main = "", xlab = "EIP Elevation (masl)")
hist(MH_N$elevation, main = "", xlab = "MH Elevation (masl)")
hist(LIP_N$elevation, main = "", xlab = "LIP Elevation (masl)")
hist(LH_N$elevation, main = "", xlab = "LH Elevation (masl)")

```
In general there are more low than middle and high elevation individuals in the data, but this varies by time period. 

```{r}

par(pty = "s", mfrow = c(2,2))
hist(EIP_C$elevation, main = "", xlab = "EIP Elevation (masl)")
hist(MH_C$elevation, main = "", xlab = "MH Elevation (masl)")
hist(LIP_C$elevation, main = "", xlab = "LIP Elevation (masl)")
hist(LH_C$elevation, main = "", xlab = "LH Elevation (masl)")

```
In general there are more low than middle and high elevation individuals in the data, but this varies by time period. 
Prep data for making Figure 2 - boxplots of isotope distribution by period
```{r}
dat.all.n.fc <- dat.all.n#make a new dataframe
dat.all.n.fc$Phase <- as.factor(dat.all.n.fc$Phase)#make phase a factor level
dat.all.c.fc <- dat.all.c
dat.all.c.fc$Phase <- as.factor(dat.all.c.fc$Phase)
```

Make Figure 2 - Boxplot for variation by time period

```{r}
#png("Fig3.boxplots.png", width=8, height=8, units="in", res=300)
par(pty="s", mfrow = c(1,2))
boxplot(dat.all.n.fc$N.b.coll.~dat.all.n.fc$Phase, xlab = "Period", ylab = expression({delta}^15*N~'\u2030'), xaxt = "n", ylim = c(5,30), col = viridis(4))
axis(1, at = seq(1,4,1), labels = c("EIP", "MH", "LIP", "LH"))
boxplot(dat.all.c.fc$C.b.coll.~dat.all.c.fc$Phase, xlab = "Period", ylab = expression({delta}^13*C~'\u2030'), xaxt = "n", ylim = c(-25, -5), col = viridis(4))
axis(1, at = seq(1,4,1), labels = c("EIP", "MH", "LIP", "LH"))
#dev.off()
```

5.5  Make Figure 1 - the map of individuals (by site) for each time period

```{r multi-map}
sites <- dat.all[ !duplicated(dat.all$Site.ID),]#select one individual from each unique site. Use this for plotting and for jittering the site points.

eip.sites <- sites[which(sites$Phase=="Early Intermediate Period"),]
mh.sites <- sites[which(sites$Phase=="Middle Horizon"),]
lip.sites <- sites[which(sites$Phase=="Late Intermediate Period"),]
lh.sites <- sites[which(sites$Phase=="Late Horizon"),]


#png("Fig1.sites_map.png", width=8, height=8, units="in", res=300)
par(oma=c(3,4,1,3))
par(mfcol=c(2,2))
par(mar=c(1.5,0,0.5,1))
par(mgp=c(0,1,0))
#par(oma=c(5,3,1,3))
plot(dem, col = c("white", rev(gray.colors(10, start = 0))), xlim = c(-82, -66), legend = FALSE, xaxt="n")#plot the composite DEM with 0 values as white and elevation in greyscale from light (low) to dark (high)
plot(crop.coast$geometry, add = T, lwd = 1.5)#plot the coastlines
plot(crop.wdbii$geometry, add = T, lwd = 1.5)#plot political boundaries from the CIA database
points(eip.sites$Longitude, eip.sites$Latitude, pch = 22, cex = 1.5, col = "black", bg = "transparent")#add the individuals to the map
#mtext("MASL", side = 4, line = 2, at = -4, las = 1)
text(x=-85, y =-24, "Early Intermediate Period", pos=4)
mtext("Latitude", side = 2, line = 3, at = -19.75, adj = 2)
maps::map.scale(x=-82.5, #map scale
                y=-21, 
                relwidth = 0.2,
                metric = TRUE, 
                ratio = FALSE, 
                cex=.5
                ) 
north.arrow(xb=-83.5, yb=-21.85, len=0.4, lab="N", cex.lab=.7, col="black")  #north arrow

plot(dem, col = c("white", rev(gray.colors(10, start = 0))), xlim = c(-82, -66), xaxt="n", yaxt = "n")#plot the composite DEM with 0 values as white and elevation in greyscale from light (low) to dark (high)
plot(crop.coast$geometry, add = T, lwd = 1.5)#plot the coastlines
plot(crop.wdbii$geometry, add = T, lwd = 1.5)#plot political boundaries from the CIA database
points(mh.sites$Longitude, mh.sites$Latitude, pch = 22, cex = 1.5, col = "black", bg = "transparent")#add the individuals to the map
mtext("MASL", side = 4, line = 1, at = -4, las = 1)
text(x=-85, y =-24, "Middle Horizon", pos=4)
maps::map.scale(x=-82.5, #map scale
                y=-21, 
                relwidth = 0.2,
                metric = TRUE, 
                ratio = FALSE, 
                cex=.5
                ) 
north.arrow(xb=-83.5, yb=-21.85, len=0.4, lab="N", cex.lab=.7, col="black")  #north arrow

plot(dem, col = c("white", rev(gray.colors(10, start = 0))), xlim = c(-82, -66), legend = FALSE)#plot the composite DEM with 0 values as white and elevation in greyscale from light (low) to dark (high)
plot(crop.coast$geometry, add = T, lwd = 1.5)#plot the coastlines
plot(crop.wdbii$geometry, add = T, lwd = 1.5)#plot political boundaries from the CIA database
points(lip.sites$Longitude, lip.sites$Latitude, pch = 22, cex = 1.5, col = "black", bg = "transparent")#add the individuals to the map
#mtext("MASL", side = 4, line = 2, at = -4, las = 1)
text(x=-85, y =-24, "Late Intermediate Period", pos=4)
maps::map.scale(x=-82.5, #map scale
                y=-21, 
                relwidth = 0.2,
                metric = TRUE, 
                ratio = FALSE, 
                cex=.5
                ) 
north.arrow(xb=-83.5, yb=-21.85, len=0.4, lab="N", cex.lab=.7, col="black")  #north arrow

plot(dem, col = c("white", rev(gray.colors(10, start = 0))), xlim = c(-82, -66), yaxt="n")#plot the composite DEM with 0 values as white and elevation in greyscale from light (low) to dark (high)
plot(crop.coast$geometry, add = T, lwd = 1.5)#plot the coastlines
plot(crop.wdbii$geometry, add = T, lwd = 1.5)#plot political boundaries from the CIA database
points(lh.sites$Longitude, lh.sites$Latitude, pch = 22, cex = 1.5, col = "black", bg = "transparent")#add the individuals to the map
mtext("MASL", side = 4, line = 1, at = -4, las = 1)
text(x=-85, y =-24, "Late Horizon", pos=4)
maps::map.scale(x=-82.5, #map scale
                y=-21, 
                relwidth = 0.2,
                metric = TRUE, 
                ratio = FALSE, 
                cex=.5
                ) 
north.arrow(xb=-83.5, yb=-21.85, len=0.4, lab="N", cex.lab=.7, col="black")  #north arrow
mtext("Longitude", side = 1, line = 3, at = -87.5, las = 1)



#dev.off()

```



5.6 Check for Site Autocorrelation
It may be reasonably expected that individuals at the same site would be more alike each other in terms of diet than they would be like individuals from other sites. Therefore we check to see if there is autocorrelation in diet by site. If yes, this implies that site should be included in the statistical model as a random effect. We check for autocorrelation using Moran's I.
```{r MoranI}

#build a simple matrix indicating if corresponding individual is 
#of the same site.id, 0 = same site.id
site.dist.inv<-as.matrix(dist(as.numeric(dat.all$Site.ID)))

#set all values below 1 to -1, indicating that they are the same site.id
site.dist.inv[site.dist.inv < 1]<--1                
#set all values above 1 to 0, indicating that they are not the same site.id
site.dist.inv[site.dist.inv > 1]<-0                 
#return negative values to 1, indicating that they are  the same site.id
site.dist.inv[site.dist.inv < 0]<-1                  

#calculate global Moran's I for nitrogen 
data.frame("Site" = round(unlist(c(Moran.I(dat.all$N.b.coll., site.dist.inv, na.rm=T))), 4))

#calculate global Moran's I for carbon 
data.frame("Site" = round(unlist(c(Moran.I(dat.all$C.b.coll., site.dist.inv, na.rm=T))), 4))


```

There is significant autocorrelation in the response variables, indicating that individuals at the same site are more like one another than expected by chance. This is therefore controlled for in the GAM by including site.id as a random effect.

5.8 Collinearity and GAM Statistical Analyses
We expect most of the environmental variables to be linearly related to dietary measures. Mean temp and precip should be linear, meaning we wouldn't expect similar dietary signatures at low and high temp but different in the middle ranges. Same for precipitation. This also holds for seasonality. Because of this we keep these measures in the parametric portion of the GAMs. Doing so (keeping parametric) essentially makes the knots=1 (relationship can only vary in 1 direction). This also means that what we want to check for is collinearity among the predictors. However, we do want elevation to be able to vary more than once. This is because we would expect coastal signatures (marine) and high elevation (camelid herding) to have higher N values whereas mid-elevations should have lower ones. Therefore elevations needs to be made a smoothed term (which allows for more than one change in direction of variation). To check for collinearity we generate a correlation matrix of predictor variables. Any variables with a correlation coefficient above 0.7 may distort model estimation and will require removal of one of the variables - correlation coefficients under 0.7 are not likely to distort model estimation (Dormann et al 2013).


5.8A EIP
Check for collinearity problems among the EIP individuals with Nitrogen values
```{r eip n collinearity}
#before calculate this reduce dataset to only those with N or C
EIP_N <- subset(dat.eip, !is.na(dat.eip$N.b.coll.))#leave out individuals with NA for N bone coll

EIP_N <- EIP_N[order(-EIP_N$Start.BP),]


#Create a function for identifying collinearity among variables
cor.mtest <- function(mat) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j])
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}


#build a data frame of predictor variables
EIP_AllVars_Pred<-with(EIP_N, 
             data.frame(
                    dist2coast, #Distance to the Coast (m)
                    Temp_Mean, #Mean Temperature (c)
                    elevation, #Elevation above sea level (masl)
                    Precip_Mean, #Mean Precipitation (mm)
                    Temp_Mean_Seasonality, #Mean seasonality of temperature over the year
                    Precip_Mean_Seasonality #Mean seasonality of precipitation over the year
             )
           )

#then test collinearity
cm<- cor(EIP_AllVars_Pred,
         method="pearson",
         use="pairwise.complete.obs")


# matrix of the p-value of the correlation
p.mat<-cor.mtest(EIP_AllVars_Pred)

#plot the correlation matrix
corrplot(cm,
      method="color",
      type="upper",
      diag=FALSE,
      bg="grey90",
      addCoef.col = "black",
      tl.col="black",
      outline = FALSE,
      addCoefasPercent=TRUE,
      p.mat = p.mat, sig.level = 0.05, insig = "blank"
  )


```

Elevation and dist2coast are highly correlated (>0.70) and therefore including both is problematic. We drop distance 2 coast in favor of elevation because elevation more directly relates to the natural zones (Pulgar Vidal 1981) than dist2coast. All other variables are < 0.70 in the collinearity matrix and therefore are fine to include in the model.

Then run the GAM for EIP individuals with Nitrogen values
```{r eip n gam}

#Construct the GAM
#Note: Lat/Long are not included because doing so doesn't change the deviance explained but removes all of the variance explained by the environmental variables (in essence all of the climatic variables are correlated with lat/long so we drop lat/long in favor of exploring the individual environmental measures). Site.ID is included due to the demonstrated autocorrelation.

EIP.par.gam <- gam(N.b.coll.~ + s(Site.ID, bs = "re") + s(elevation)  + Temp_Mean  + Precip_Mean + Temp_Mean_Seasonality + Precip_Mean_Seasonality, 
                     family = gaussian(link = "identity"),
                     method = "REML",
                     data=EIP_N[order(-EIP_N$Start.BP),]
                    )

```

Check the residuals
```{r}
#check model residuals
par(pty='s')
hist(residuals(EIP.par.gam, type = "response"), main = NA, xlab = "Model Residuals", col = "grey80")
#residuals look good
```
The residuals are normally distributed around 0

Check for adequate smoothing of elevation
```{r}
k.check(EIP.par.gam)
```
Elevation is adequately smoothed.

Check for overdispersion
```{r}
#check overdispersion
sum(residuals(EIP.par.gam, type = "pearson")^2) / df.residual(EIP.par.gam)
```
Overdispersion is not too strong.

Run the GAM summary for results
```{r}
summary(EIP.par.gam)
```

Check for collinearity problems among the EIP individuals with Carbon values
```{r eip c collinearity}
#before calculate this reduce dataset to only those with N or C
EIP_C <- subset(dat.eip, !is.na(dat.eip$C.b.coll.))#leave out individuals with NA for C bone coll

#build a data frame of predictor variables
EIPC_AllVars_Pred<-with(EIP_C, 
             data.frame(
                    dist2coast, #Distance to the Coast (m)
                    Temp_Mean, #Mean Temperature (c)
                    elevation, #Elevation above sea level (masl)
                    Precip_Mean, #Mean Precipitation (mm)
                    Temp_Mean_Seasonality, #Mean seasonality of temperature over the year
                    Precip_Mean_Seasonality #Mean seasonality of precipitation over the year
             )
           )

#then test collinearity
cm<- cor(EIPC_AllVars_Pred,
         method="pearson",
         use="pairwise.complete.obs")


# matrix of the p-value of the correlation
p.mat<-cor.mtest(EIPC_AllVars_Pred)

#plot the correlation matrix
corrplot(cm,
      method="color",
      type="upper",
      diag=FALSE,
      bg="grey90",
      addCoef.col = "black",
      tl.col="black",
      outline = FALSE,
      addCoefasPercent=TRUE,
      p.mat = p.mat, sig.level = 0.05, insig = "blank"
  )

```
Elevation and dist2coast are highly correlated (>0.70) and therefore including both is problematic. We drop distance 2 coast in favor of elevation. All other variables are < 0.70 in the collinearity matrix and therefore are fine to include in the model.

Run the GAM for individuals with carbon values
```{r eip c gam}

EIPC.gam <- gam(C.b.coll.~ s(Site.ID, bs = "re") + Temp_Mean + s(elevation) + Precip_Mean + Temp_Mean_Seasonality + Precip_Mean_Seasonality,
                     family = gaussian(link = "identity"),
                     method = "REML",
                     data=EIP_C[order(-EIP_C$Start.BP),]
                    )
```

Check model residuals
```{r}
par(pty='s')
hist(residuals(EIPC.gam, type = "response"), main = NA, xlab = "Model Residuals", col = "grey80")
```
The residuals are mostly normally distributed around 0.

Check to see if elevation is adequately smoothed
```{r}
k.check(EIPC.gam)
```
Elevation is adequately smoothed

Check for overdispersion
```{r}
sum(residuals(EIPC.gam, type = "pearson")^2) / df.residual(EIPC.gam)
```
Residuals are not overdispersed

Run the GAM summary for results
```{r}
summary(EIPC.gam)
```


5.8B Middle Horizon

Check for collinearity problems among the MH individuals with Nitrogen values
```{r mh n collinearity}
#before calculate this reduce dataset to only those with N or C
MH_N <- subset(dat.mh, !is.na(dat.mh$N.b.coll.))#leave out individuals with NA for N bone coll


#build a data frame of predictor variables
MHN_AllVars_Pred<-with(MH_N, 
             data.frame(
                    dist2coast, #Distance to the Coast (m)
                    Temp_Mean, #Mean Temperature (c)
                    elevation, #Elevation above sea level (masl)
                    Precip_Mean, #Mean Precipitation (mm)
                    Temp_Mean_Seasonality, #Mean seasonality of temperature over the year
                    Precip_Mean_Seasonality #Mean seasonality of precipitation over the year
             )
           )

#then test collinearity
cm<- cor(MHN_AllVars_Pred,
         method="pearson",
         use="pairwise.complete.obs")


# matrix of the p-value of the correlation
p.mat<-cor.mtest(MHN_AllVars_Pred)

#plot the correlation matrix
corrplot(cm,
      method="color",
      type="upper",
      diag=FALSE,
      bg="grey90",
      addCoef.col = "black",
      tl.col="black",
      outline = FALSE,
      addCoefasPercent=TRUE,
      p.mat = p.mat, sig.level = 0.05, insig = "blank"
  )

```
Elevation and dist2coast are highly correlated (>0.70) and therefore including both is problematic. We drop distance 2 coast in favor of elevation. Precip_Mean and Precip_Seasonality are also correlated >0.70. We drop Precip_Seasonality as a model with Precip_Mean outperforms the model with Precip_Seasonality based on AIC and we expect mean precipitation to be a more important factor in the underlying resource distributions.

Run the GAM for MH Nitrogen
```{r mh n gam}

MHNgam <- gam(N.b.coll.~ s(Site.ID, bs = "re") + Temp_Mean + s(elevation) + Precip_Mean + Temp_Mean_Seasonality,
                     family = gaussian(link = "identity"),
                     method = "REML",
                     data=MH_N[order(-MH_N$Start.BP),]
                    )

```

Check model residuals
```{r}
par(pty='s')
hist(residuals(MHNgam, type = "response"), main = NA, xlab = "Model Residuals", col = "grey80")
```
Residuals are normally distributed around 0

Check to see if elevation is adequately smoothed
```{r}
k.check(MHNgam)
```
Elevation could be smoothed further, but changing the knots does not improve this. For the sake of comparison, we keep elevation as is so that this model may be directly compared with all others.

Check for overdispersion
```{r}
sum(residuals(MHNgam, type = "pearson")^2) / df.residual(MHNgam)
```
The model residuals are not overdispersed

Run the GAM summary for results
```{r}
summary(MHNgam)
```

Check for collinearity problems among the MH individuals with Carbon values
```{r mh c collinearity}
#before calculate this reduce dataset to only those with N or C
MH_C <- subset(dat.mh, !is.na(dat.mh$C.b.coll.))#leave out individuals with NA for C bone coll


#build a data frame of predictor variables
MHC_AllVars_Pred<-with(MH_C, 
             data.frame(
                    dist2coast, #Distance to the Coast (m)
                    Temp_Mean, #Mean Temperature (c)
                    elevation, #Elevation above sea level (masl)
                    Precip_Mean, #Mean Precipitation (mm)
                    Temp_Mean_Seasonality, #Mean seasonality of temperature over the year
                    Precip_Mean_Seasonality #Mean seasonality of precipitation over the year
             )
           )

#then test collinearity
cm<- cor(MHC_AllVars_Pred,
         method="pearson",
         use="pairwise.complete.obs")


# matrix of the p-value of the correlation
p.mat<-cor.mtest(MHC_AllVars_Pred)

#plot the correlation matrix
corrplot(cm,
      method="color",
      type="upper",
      diag=FALSE,
      bg="grey90",
      addCoef.col = "black",
      tl.col="black",
      outline = FALSE,
      addCoefasPercent=TRUE,
      p.mat = p.mat, sig.level = 0.05, insig = "blank"
  )

```
Elevation and dist2coast are highly correlated (>0.70) and therefore including both is problematic. We drop distance 2 coast in favor of elevation. Precip_Mean and Precip_Seasonality are also >0.70. We drop Precip_Seasonality as a model with Precip_Mean outperforms the model with Precip_Seasonality based on AIC and we expect mean precipitation to be a more important factor in the underlying resource distributions.

Run the MH GAM for Carbon
```{r mh c gam}

MHC.gam <- gam(C.b.coll.~ s(Site.ID, bs = "re") + Temp_Mean + s(elevation) + Precip_Mean + Temp_Mean_Seasonality,
                     family = gaussian(link = "identity"),
                     method = "REML",
                     data=MH_C[order(-MH_C$Start.BP),]
                    )
```

Check model residuals
```{r}
par(pty='s')
hist(residuals(MHC.gam, type = "response"), main = NA, xlab = "Model Residuals", col = "grey80")
```
Residuals are normally distributed around 0

Check to see if elevation is adequately smoothed
```{r}
k.check(MHC.gam)
```
Elevation could be smoothed further, but changing the knots does not improve this. For the sake of comparison, we keep elevation as is so that this model may be directly compared with all others.

Check for overdispersion
```{r}
sum(residuals(MHC.gam, type = "pearson")^2) / df.residual(MHC.gam)
```
The residuals are not overdispersed

Run GAM summary for results
```{r}
summary(MHC.gam)
```

5.8C Late Intermediate Period (LIP)

Check for collinearity problems among the LIP individuals with Nitrogen values
```{r lip n collinearity}
#before calculate this reduce dataset to only those with N or C
LIP_N <- subset(dat.lip, !is.na(dat.lip$N.b.coll.))#leave out individuals with NA for N bone coll

#build a data frame of predictor variables
LIPN_AllVars_Pred<-with(LIP_N, 
             data.frame(
                    dist2coast, #Distance to the Coast (m)
                    Temp_Mean, #Mean Temperature (c)
                    elevation, #Elevation above sea level (masl)
                    Precip_Mean, #Mean Precipitation (mm)
                    Temp_Mean_Seasonality, #Mean seasonality of temperature over the year
                    Precip_Mean_Seasonality #Mean seasonality of precipitation over the year
             )
           )

#then test collinearity
cm<- cor(LIPN_AllVars_Pred,
         method="pearson",
         use="pairwise.complete.obs")


# matrix of the p-value of the correlation
p.mat<-cor.mtest(LIPN_AllVars_Pred)

#plot the correlation matrix
corrplot(cm,
      method="color",
      type="upper",
      diag=FALSE,
      bg="grey90",
      addCoef.col = "black",
      tl.col="black",
      outline = FALSE,
      addCoefasPercent=TRUE,
      p.mat = p.mat, sig.level = 0.05, insig = "blank"
  )

```
Elevation and dist2coast are highly correlated (>0.70) and therefore including both is problematic. We drop distance 2 coast in favor of elevation. Precip_Mean and Precip_Seasonality are also >0.70. We drop Precip_Seasonality as a model with Precip_Mean outperforms the model with Precip_Seasonality based on AIC and we expect mean precipitation to be a more important factor in the underlying resource distributions. For the same reason we drop Temp_Mean_Seasonality which is highly correlated with Precip_Mean (>0.70). 

Run the LIP Nitrogen GAM
```{r lip n gam}

LIPNgam <- gam(N.b.coll.~ s(elevation) + Precip_Mean  + Precip_Mean_Seasonality +s(Site.ID, bs = "re"),
                     family = gaussian(link = "identity"),
                     method = "REML",
                     data=LIP_N[order(-LIP_N$Start.BP),]
                    )
```

Check model residuals
```{r}
par(pty='s')
hist(residuals(LIPNgam, type = "response"), main = NA, xlab = "Model Residuals", col = "grey80")
```
Residuals are normally distributed around 0

Check to see if elevation is adequately smoothed
```{r}
k.check(LIPNgam)
```
Elevation is adequately smoothed

Check for overdispersion
```{r}
sum(residuals(LIPNgam, type = "pearson")^2) / df.residual(LIPNgam)
```
The model is not overdispersed

Run GAM summary for results
```{r}
summary(LIPNgam)
```

Check for collinearity problems among the LIP individuals with Carbon values
```{r lip c collinearity}
#before calculate this reduce dataset to only those with N or C
LIP_C <- subset(dat.lip, !is.na(dat.lip$C.b.coll.))#leave out individuals with NA for C bone coll

#build a data frame of predictor variables
LIPC_AllVars_Pred<-with(LIP_C, 
             data.frame(
                    dist2coast, #Distance to the Coast (m)
                    Temp_Mean, #Mean Temperature (c)
                    elevation, #Elevation above sea level (masl)
                    Precip_Mean, #Mean Precipitation (mm)
                    Temp_Mean_Seasonality, #Mean seasonality of temperature over the year
                    Precip_Mean_Seasonality #Mean seasonality of precipitation over the year
             )
           )

#then test collinearity
cm<- cor(LIPC_AllVars_Pred,
         method="pearson",
         use="pairwise.complete.obs")


# matrix of the p-value of the correlation
p.mat<-cor.mtest(LIPC_AllVars_Pred)

#plot the correlation matrix
corrplot(cm,
      method="color",
      type="upper",
      diag=FALSE,
      bg="grey90",
      addCoef.col = "black",
      tl.col="black",
      outline = FALSE,
      addCoefasPercent=TRUE,
      p.mat = p.mat, sig.level = 0.05, insig = "blank"
  )

```
Elevation and dist2coast are highly correlated (>0.70) and therefore including both is problematic. We drop distance 2 coast in favor of elevation. Precip_Mean and Precip_Seasonality are also >0.70. We drop Precip_Seasonality as a model with Precip_Mean outperforms the model with Precip_Seasonality based on AIC and we expect mean precipitation to be a more important factor in the underlying resource distributions. For the same reason we drop Temp_Mean_Seasonality which is highly correlated with Precip_Mean (>0.70). 

Run the LIP Carbon GAM
```{r lip c gam}

LIPC.gam <- gam(C.b.coll.~ s(elevation) + Precip_Mean + Precip_Mean_Seasonality +s(Site.ID, bs = "re"),
                     family = gaussian(link = "identity"),
                     method = "REML",
                     data=LIP_C[order(-LIP_C$Start.BP),]
                    )
```

Check model residuals
```{r}
par(pty='s')
hist(residuals(LIPC.gam, type = "response"), main = NA, xlab = "Model Residuals", col = "grey80")
```
There is slight skew, but generally the residuals are normally distributed around 0

Check for adequate smoothing of elevation
```{r}
k.check(LIPC.gam)
```
Elevation is adequately smoothed

Check for overdispersion
```{r}
sum(residuals(LIPC.gam, type = "pearson")^2) / df.residual(LIPC.gam)
```
Model residuals are not overdispersed

Run GAM summary for results
```{r}
summary(LIPC.gam)
```


5.8D Late Horizon (LH)

Check for collinearity problems among the LH individuals with Nitrogen values
```{r lh n collinearity}
#before calculate this reduce dataset to only those with N or C
LH_N <- subset(dat.lh, !is.na(dat.lh$N.b.coll.))#leave out individuals with NA for N bone coll


#build a data frame of predictor variables
LHPN_AllVars_Pred<-with(LH_N, 
             data.frame(
                    dist2coast, #Distance to the Coast (m)
                    Temp_Mean, #Mean Temperature (c)
                    elevation, #Elevation above sea level (masl)
                    Precip_Mean, #Mean Precipitation (mm)
                    Temp_Mean_Seasonality, #Mean seasonality of temperature over the year
                    Precip_Mean_Seasonality #Mean seasonality of precipitation over the year
             )
           )

#then test collinearity
cm<- cor(LHPN_AllVars_Pred,
         method="pearson",
         use="pairwise.complete.obs")


# matrix of the p-value of the correlation
p.mat<-cor.mtest(LHPN_AllVars_Pred)

#plot the correlation matrix
corrplot(cm,
      method="color",
      type="upper",
      diag=FALSE,
      bg="grey90",
      addCoef.col = "black",
      tl.col="black",
      outline = FALSE,
      addCoefasPercent=TRUE,
      p.mat = p.mat, sig.level = 0.05, insig = "blank"
  )



```
Elevation and dist2coast are highly correlated (>0.70) and therefore including both is problematic. We drop distance 2 coast in favor of elevation . Precip_Mean_Seasonality and Temp_Mean_Seasonality are also >0.70. We drop Precip_Seasonality for comparability, in all other periods where predictor variables are dropped precip_mean_seasonality is among those removed and we do so again here.

Run LH nitrogen GAM
```{r lh n gam}

LHNgam <- gam(N.b.coll.~ Temp_Mean + s(elevation, k = 3) +Precip_Mean + Temp_Mean_Seasonality +s(Site.ID, bs = "re"),
                     family = gaussian(link = "identity"),
                     method = "REML",
                     data=LH_N[order(-LH_N$Start.BP),]
                    )
```

Check model residuals
```{r}
par(pty='s')
hist(residuals(LHNgam, type = "response"), main = NA, xlab = "Model Residuals", col = "grey80")
```
There is slight skew, but the residuals are mostly normally distributed around 0

Check if elevation is adequately smoothed
```{r}
k.check(LHNgam)
```
Elevation is adequately smoothed

Check for overdispersion
```{r}
sum(residuals(LHNgam, type = "pearson")^2) / df.residual(LHNgam)
```
Residuals are not overdispersed

Run GAM summary for results
```{r}
summary(LHNgam)
```

Check for collinearity problems among the LH individuals with Carbon values
```{r lh c collinearity}
#before calculate this reduce dataset to only those with N or C
LH_C <- subset(dat.lh, !is.na(dat.lh$C.b.coll.))#leave out individuals with NA for C bone coll


#build a data frame of predictor variables
LHC_AllVars_Pred<-with(LH_C, 
             data.frame(
                    dist2coast, #Distance to the Coast (m)
                    Temp_Mean, #Mean Temperature (c)
                    elevation, #Elevation above sea level (masl)
                    Precip_Mean, #Mean Precipitation (mm)
                    Temp_Mean_Seasonality, #Mean seasonality of temperature over the year
                    Precip_Mean_Seasonality #Mean seasonality of precipitation over the year
             )
           )


#then test collinearity
cm<- cor(LHC_AllVars_Pred,
         method="pearson",
         use="pairwise.complete.obs")


# matrix of the p-value of the correlation
p.mat<-cor.mtest(LHC_AllVars_Pred)

#plot the correlation matrix
corrplot(cm,
      method="color",
      type="upper",
      diag=FALSE,
      bg="grey90",
      addCoef.col = "black",
      tl.col="black",
      outline = FALSE,
      addCoefasPercent=TRUE,
      p.mat = p.mat, sig.level = 0.05, insig = "blank"
  )
```
Elevation and dist2coast are highly correlated (>0.70) and therefore including both is problematic. We drop distance 2 coast in favor of elevation. Precip_Mean_Seasonality and Temp_Mean_Seasonality are also >0.70. We drop Precip_Seasonality for comparability, in all other periods where predictor variables are dropped precip_mean_seasonality is among those removed and we do so again here.

Run the LH Carbon GAM
```{r lh c gam}


LHC.gam <- gam(C.b.coll.~ Temp_Mean + s(elevation, k = 3) +Precip_Mean + Temp_Mean_Seasonality +s(Site.ID, bs = "re"),
                     family = gaussian(link = "identity"),
                     method = "REML",
                     data=LH_C[order(-LH_C$Start.BP),]
                    )
```

Check model residuals
```{r}
par(pty='s')
hist(residuals(LHC.gam, type = "response"), main = NA, xlab = "Model Residuals", col = "grey80")
```
Residuals are normally distributed around 0

Check for adequate smoothing of elevation
```{r}
k.check(LHC.gam)
```
Elevation could be smoothed further, but changing the knots does not improve this. For the sake of comparison, we keep elevation as is so that this model may be directly compared with all others.

Check for overdispersion
```{r}
sum(residuals(LHC.gam, type = "pearson")^2) / df.residual(LHC.gam)
```
Residuals are not overdispersed

Run GAM summary for results
```{r}
summary(LHC.gam)
```



5.8E All Individuals

Check for collinearity problems among the individuals with Nitrogen values
```{r all n collinearity}
#before calculate this reduce dataset to only those with N or C
dat_N <- subset(dat.all, !is.na(dat.all$N.b.coll.))#leave out individuals with NA for N bone coll

#Create a function for identifying collinearity among variables
cor.mtest <- function(mat) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j])
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}


#build a data frame of predictor variables
dat_AllVars_Pred<-with(dat_N, 
             data.frame(
                    dist2coast, #Distance to the Coast (m)
                    Temp_Mean, #Mean Temperature (c)
                    elevation, #Elevation above sea level (masl)
                    Precip_Mean, #Mean Precipitation (mm)
                    Temp_Mean_Seasonality, #Mean seasonality of temperature over the year
                    Precip_Mean_Seasonality #Mean seasonality of precipitation over the year
             )
           )

#then test collinearity
cm<- cor(dat_AllVars_Pred,
         method="pearson",
         use="pairwise.complete.obs")


# matrix of the p-value of the correlation
p.mat<-cor.mtest(dat_AllVars_Pred)

#plot the correlation matrix
corrplot(cm,
      method="color",
      type="upper",
      diag=FALSE,
      bg="grey90",
      addCoef.col = "black",
      tl.col="black",
      outline = FALSE,
      addCoefasPercent=TRUE,
      p.mat = p.mat, sig.level = 0.05, insig = "blank"
  )
```
Elevation and dist2coast are highly correlated (>0.70) and therefore including both is problematic. We drop distance 2 coast in favor of elevation. All other variables are < 0.70 in the collinearity matrix and therefore are fine to include in the model.

Run the GAM for all individuals with Nitrogen
```{r all n gam}

dat_N$Site.ID <- as.factor(dat_N$Site.ID)

dat.par.gam <- gam(N.b.coll.~ Temp_Mean + s(elevation) + Precip_Mean + Temp_Mean_Seasonality + Precip_Mean_Seasonality +s(Site.ID, bs = "re"),
                     family = gaussian(link = "identity"),
                     method = "REML",
                     data=dat_N[order(-dat_N$Start.BP),]
                    )
```

Check model residuals
```{r}
par(pty='s')
hist(residuals(dat.par.gam, type = "response"), main = NA, xlab = "Model Residuals", col = "grey80")
```
Residuals are normally distributed around 0

Check for adequate smoothing of elevation
```{r}
k.check(dat.par.gam)
```
Elevation is adequately smoothed

Check for overdispersion
```{r}
sum(residuals(dat.par.gam, type = "pearson")^2) / df.residual(dat.par.gam)
```
Model residuals are not overdispersed

Run GAM summary for results
```{r}
summary(dat.par.gam)

```

Check for collinearity problems among the individuals with Carbon values
```{r all c collinearity}
#before calculate this reduce dataset to only those with N or C
dat_C <- subset(dat.all, !is.na(dat.all$C.b.coll.))#leave out individuals with NA for C bone coll


#build a data frame of predictor variables
datC_AllVars_Pred<-with(dat_C, 
             data.frame(
                    dist2coast, #Distance to the Coast (m)
                    Temp_Mean, #Mean Temperature (c)
                    elevation, #Elevation above sea level (masl)
                    Precip_Mean, #Mean Precipitation (mm)
                    Temp_Mean_Seasonality, #Mean seasonality of temperature over the year
                    Precip_Mean_Seasonality #Mean seasonality of precipitation over the year
             )
           )

#then test collinearity
cm<- cor(datC_AllVars_Pred,
         method="pearson",
         use="pairwise.complete.obs")


# matrix of the p-value of the correlation
p.mat<-cor.mtest(datC_AllVars_Pred)

#plot the correlation matrix
corrplot(cm,
      method="color",
      type="upper",
      diag=FALSE,
      bg="grey90",
      addCoef.col = "black",
      tl.col="black",
      outline = FALSE,
      addCoefasPercent=TRUE,
      p.mat = p.mat, sig.level = 0.05, insig = "blank"
  )
```
Elevation and dist2coast are highly correlated (>0.70) and therefore including both is problematic. We drop distance 2 coast in favor of elevation. All other variables are < 0.70 in the collinearity matrix and therefore are fine to include in the model.

Run the GAM for all individuals with Carbon
```{r all c gam}
dat_C$Site.ID <- as.factor(dat_C$Site.ID)

datC.gam <- gam(C.b.coll.~ Temp_Mean + s(elevation) + Precip_Mean + Temp_Mean_Seasonality + Precip_Mean_Seasonality +s(Site.ID, bs = "re"),
                     family = gaussian(link = "identity"),
                     method = "REML",
                     data=dat_C[order(-dat_C$Start.BP),]
                    )
```

Check model residuals
```{r}
par(pty='s')
hist(residuals(datC.gam, type = "response"), main = NA, xlab = "Model Residuals", col = "grey80")
```
Residuals are normally distributed around 0

Check for adequate smoothing of elevation
```{r}
k.check(datC.gam)
```
Elevation could be smoothed further, but changing the knots does not improve this. For the sake of comparison, we keep elevation as is so that this model may be directly compared with all others.

Check for overdispersion
```{r}
sum(residuals(datC.gam, type = "pearson")^2) / df.residual(datC.gam)
```
Model residuals are not overdispersed

Run GAM summary for results
```{r}
summary(datC.gam)
```

6.1 Make Figure 4 - comparison of deviances explained
```{r barplot}

#take the amount of the deviance explained for each time period and put it in a table
n.table <- data.frame(period=c("EIP", "MH", "LIP", "LH"), dev.ex=c(92.4, 69.0, 62.1, 91.1))
n.table

c.table <- data.frame(period=c("EIP", "MH", "LIP", "LH"), dev.ex=c(83.4, 53.0, 53.1, 46.0))
c.table

#png("Fig4.model_deviance_exp.png", width=8, height=8, units="in", res=300)
par(pty="s", mfrow=c(1,2), mar=c(5.1, 5.1, 4.1, 1.1), xpd=TRUE)
nbp <- barplot(n.table$dev.ex, ylim = c(0, 100), ylab = "Amount Explained", col=viridis(4), xlab = "", names.arg=c("EIP", "MH", "LIP", "LH"), density = c(50, 100, 100, 50), angle = c(45, 135, 45, 135))
text(x=nbp, y=n.table$dev.ex, label = c("92.4%", "69.0%", "62.1%", "91.1%"), pos = 3, cex= 0.75)
text(x=2.5, y=110, label=expression({delta}^15*N~'\u2030'))

par(mar=c(5.1, 1.1, 4.1, 5.1))
cbp <- barplot(c.table$dev.ex, ylim = c(0, 100), ylab = "", col=viridis(4), xlab = "", names.arg=c("EIP", "MH", "LIP", "LH"), density = c(50, 100, 100, 50), angle = c(45, 135, 45, 135))
text(x=cbp, y=c.table$dev.ex, label = c("83.4%", "53.0%", "53.1%", "46.0%"), pos = 3, cex= 0.75)
text(x=2.5, y=110, label=expression({delta}^13*C~'\u2030'))

mtext("Time Period", side = 1, line = 3, at = -.5)

#dev.off()

#reduce mar of right side in left plot and left side in right plot (equal amount) by using par for each of them.
```


6.2 Create objects with residuals for stripchart plotting
```{r}

Nitrogen.resids <- data.frame(cbind(residuals(EIP.par.gam, type = "response"), residuals(MHNgam, type = "response"), residuals(LIPNgam, type = "response"), residuals(LHNgam, type = "response")))
colnames(Nitrogen.resids) <- c("EIP", "MH", "LIP", "LH")

Carbon.resids <- data.frame(cbind(residuals(EIPC.gam, type = "response"), residuals(MHC.gam, type = "response"), residuals(LIPC.gam, type = "response"), residuals(LHC.gam, type = "response")))
colnames(Carbon.resids) <- c("EIP", "MH", "LIP", "LH")
```

Make Figure 5 - distribution of residuals
```{r}

#png("Fig5.model_residuals.png", width=8, height=8, units="in", res=300)
par(pty = "s", mfrow = c(1,2), bty = 'n')
stripchart(Nitrogen.resids, group.names = c("EIP", "MH", "LIP", "LH"), vertical = TRUE, col=viridis(4), ylab = "Nitrogen Model Residuals", ylim = c(-10,10))
#boxplot(Nitrogen.resids, xlab = "Period", ylab = "Residuals", xaxt = "n")
axis(1, at = seq(1,4,1), labels = c("EIP", "MH", "LIP", "LH"))

stripchart(Carbon.resids, group.names = c("EIP", "MH", "LIP", "LH"), vertical = TRUE, col=viridis(4), ylab = "Carbon Model Residuals", ylim = c(-10,10))
#boxplot(Carbon.resids, xlab = "Period", ylab = "Residuals", xaxt = "n")
axis(1, at = seq(1,4,1), labels = c("EIP", "MH", "LIP", "LH"))
mtext("Time Period", side = 1, line = 3, at = 0)
#dev.off()
```





References
Dormann, Carsten F., Jane Elith, Sven Bacher, Carsten Buchmann, Gudrun Carl, Gabriel Carre, Jaime R. Garcia Marquez et al. (2013). Collinearity: a review of methods to deal with it and a simulation study evaluating their performance. *Ecography* 36: 27-46.

Fordham, D. A., Saltr, F., Haythorne, S., Wigley, T. M., OttoBliesner, B. L., Chan, K. C., et al. (2017). PaleoView: a tool for generating continuous climate projections spanning the last 21 000 years at regional and global scales. *Ecography*, 40(11), 1348-1358.

Pulgar Vidal, J., (1981). Geografa del Per: Las ocho regiones naturales del Per, 8th ed., Editorial Universo, Lima, Peru.
